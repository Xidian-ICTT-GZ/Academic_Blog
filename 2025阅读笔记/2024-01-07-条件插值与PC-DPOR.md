# **近期论文验证方法和启发的总结**



## 1.核心问题、解决方法以及实验比较

|          | 条件插值：使并发程序验证更有效                               | 优先约束辅助的动态部分阶约简                                 |
| :------- | :----------------------------------------------------------- | ------------------------------------------------------------ |
| 核心问题 | 并发程序中的线程交替导致状态空间爆炸，使得验证变得困难；传统的插值方法（如克雷格插值）在并发程序验证中效率有限。 | 并发程序中的线程交替导致路径空间爆炸.传统的部分阶约简（$POR$）方法由于依赖关系的近似不精确，仍然会探索大量冗余路径。 |
| 解决方法 | 1、引入条件插值；2、缩短插值路径；                           | 1、提出约束依赖图；2、优先探索孤立转移；3、进行动态依赖分析  |
| 方式     | 修减额外的条件分支                                           | 修减冗余分支                                                 |
| 实验比较 | 通过条件插值，探索状态的数量平均减少到29.87%，可验证的程序数量增加17.26%。 | 在验证过程中，探索的状态数平均减少了8.62%。                  |
| 不足     | 对于少量程序，该方法对验证程序数量的改进效果可能不明显；谓词可能被过度计算，导致在计算后继状态的可达区域时考虑了过多的谓词。 | 某些程序中存在共享变量的非确定性赋值，这样会导致需要探索的等价轨迹类数量的增加 |

![image-20250117143036287](C:\Users\30527\AppData\Roaming\Typora\typora-user-images\image-20250117143036287.png)

应用条件插值修剪额外的条件分支

![image-20241219131450983](C:\Users\30527\AppData\Roaming\Typora\typora-user-images\image-20241219131450983.png)

应用PC-DPOR修剪等价的冗余分支

## 2.思路

相同点：（1）两种方法都针对并发程序的验证问题，提出减少状态空间和路径空间的方法；

（2）两篇论文都使用了**抽象模型**（如控制流图$CFG$和抽象可达树ART）来表示程序的执行路径和状态。利用这种方法，可以系统地分析并发程序的行为，把程序的执行路径都可以展示出来。

（3）两篇论文都用到了动态调整的策略。条件插值在每个选择点计算条件插值，以避免探索不可行的路径；而$PC-DPOR$则是检查在给定的可达状态下相对依赖关系约束是否满足，动态地确定启用转移的依赖关系。

不同点：（1）条件插值提出了一种方法，具体地说，构造并发程序的控制流图（$CFG$）并展开它，得到抽象可达树（ART）。在展开过程中，利用从虚假反例中学习到的谓词来改进抽象模型。除了简化抽象[17]的插值（可达性插值）外，还引入了一种新的插值，即条件插值，用于ART中冗余路径的有效修剪。与大多数只有在到达错误位置时才生成谓词的抽象-细化方法不同，我们立即在每个选择点计算条件插值，以避免探索不可行的路径。生成的条件内插进一步被用来缩短内插路径，这种简化反过来减少了生成其他内插的时间消耗，而不会降低性能。

（2）$PC-DPOR$提出了一种方法，称为**优先级约束引导的动态部分顺序减少（PC-DPOR）**，旨在提高转移依赖关系分析的精度，从而大大减少冗余等效轨迹的探索。为此，首先构建了一个约束依赖图。在此基础上，通过$POR$优先探索孤立转移，从而减少冗余等效轨迹的探索。此外，通过检查在给定的可达状态下相对依赖关系约束是否满足，动态地确定启用转移的依赖关系。通过这种方式，克服了$POR$中依赖关系过度近似的固有不精确性。特别地，当约束依赖图仅包含孤立转移时，我们的方法只需探索一条轨迹，而现有的大多数$POR$技术则需要探索n!（n为线程数）条轨迹。

## 3.优化

在条件插值的最后，提出了将$POR$技术集成到条件插值里面，避免探索冗余路径；而对于$PC-DPOR$来说，需要准确估算线程创建次数的方法，以减小 $CDG$ 的规模。

其次，对于$PC-DPOR$来说，对于约束依赖图的边的集合的$\varphi$来说，计算公式只有三种情况，即1）两条赋值语句；2）一条赋值语句，一条假设语句；3）两条假设语句。但对于并发程序来说，不可能仅仅有这三种情况，因此接下来的优化工作也可以对$\varphi$计算公示的扩充。